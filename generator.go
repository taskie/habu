package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"

	"github.com/iancoleman/strcase"
)

// Generator is a generator of a source file.
type Generator struct {
	buf      bytes.Buffer
	pkgName  string
	flagSets []*FlagSet
}

func newGenerator(pkgName string, flagSets []*FlagSet) *Generator {
	return &Generator{
		buf:      bytes.Buffer{},
		pkgName:  pkgName,
		flagSets: flagSets,
	}
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// Generate a source file.
func (g *Generator) Generate() []byte {
	imported := g.collectImportedPath()
	imported["github.com/spf13/cobra"] = struct{}{}
	if *viper != "false" {
		imported["github.com/spf13/viper"] = struct{}{}
	}
	g.generateHeader(imported)
	g.generateBody()
	return g.format()
}

func (g *Generator) generateHeader(imported map[string]struct{}) {
	g.Printf("// Code generated by \"habu %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package %s\n", g.pkgName)
	g.Printf("\n")
	g.Printf("import (\n")
	for path := range imported {
		// TODO: support alias
		g.Printf("  %#v\n", path)
	}
	g.Printf(")\n")
}

func (g *Generator) collectImportedPath() map[string]struct{} {
	imported := make(map[string]struct{})
	for _, fs := range g.flagSets {
		for _, f := range fs.flags {
			p := f.parse
			splitted := strings.SplitN(p, ".", 2)
			if len(splitted) == 2 {
				imported[splitted[0]] = struct{}{}
			}
		}
	}
	return imported
}

func (g *Generator) collectHasPersistent() bool {
	for _, fs := range g.flagSets {
		for _, f := range fs.flags {
			if f.persistent {
				return true
			}
		}
	}
	return false
}

func (g *Generator) generateBody() {
	for _, fs := range g.flagSets {
		g.generatePrepareFlagsFunc(fs)
	}
}

func (g *Generator) generatePrepareFlagsFunc(fs *FlagSet) {
	if *viper != "false" {
		g.Printf("func Prepare%sFlags(c *cobra.Command, v *viper.Viper) {\n", fs.typeName)
	} else {
		g.Printf("func Prepare%sFlags(c *cobra.Command) {\n", fs.typeName)
	}
	g.Printf("  fs := c.Flags()\n")
	if g.collectHasPersistent() {
		g.Printf("  ps := c.PersistentFlags()\n")
	}
	for _, f := range fs.flags {
		g.generateFlagSetter(fs, f)
	}
	g.Printf("}\n")
}

func (g *Generator) generateFlagSetter(fs *FlagSet, f *Flag) {
	name := f.name
	if name == "_" {
		name = strcase.ToKebab(f.fieldName)
	}
	shorthand := f.shorthand
	if shorthand == "_" {
		shorthand = name[0:1]
	}
	flags := "fs"
	if f.persistent {
		flags = "ps"
	}
	switch f.fieldType {
	case String, Int, Bool, Duration:
		if f.shorthand != "" {
			g.Printf("	%s.%sP(%#v, %#v, %#v, %#v)\n", flags, strings.Title(f.fieldType.String()), name, shorthand, f.value, f.usage)
		} else {
			g.Printf("	%s.%s(%#v, %#v, %#v)\n", flags, strings.Title(f.fieldType.String()), name, f.value, f.usage)
		}
	default:
		if f.parse != "" {
			splitted := strings.SplitN(f.parse, "/", 2)
			parse := f.parse
			if len(splitted) == 2 {
				parse = splitted[1]
			}
			if f.shorthand != "" {
				g.Printf("	%s.%sP(%#v, %#v, %s(%#v), %#v)\n", flags, strings.Title(f.fieldType.String()), name, shorthand, parse, f.value, f.usage)
			} else {
				g.Printf("	%s.%s(%#v, %s(%#v), %#v)\n", flags, strings.Title(f.fieldType.String()), name, parse, f.value, f.usage)
			}
		} else {
			log.Fatalf("unsupported field type: %s", f.fieldType)
		}
	}
	if *viper != "false" {
		configName := f.viper
		if configName == "" {
			configName = f.fieldName
		}
		g.Printf("v.BindPFlag(%#v, %s.Lookup(%#v))\n", configName, flags, name)
		if f.env != "" {
			if f.env == "_" {
				g.Printf("v.BindEnv(%#v)\n", configName)
			} else {
				g.Printf("v.BindEnv(%#v, %#v)\n", configName, f.env)
			}
		}
	}
}

func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}
